\section{/home/gerac/\+Facultad/\+S\+O2/2020\+T\+P1/ejemplos/bash.c File Reference}
\label{bash_8c}\index{/home/gerac/\+Facultad/\+S\+O2/2020\+T\+P1/ejemplos/bash.\+c@{/home/gerac/\+Facultad/\+S\+O2/2020\+T\+P1/ejemplos/bash.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
Include dependency graph for bash.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{bash_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE}~1024
\item 
\#define \textbf{ L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE}~64
\item 
\#define \textbf{ L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM}~\char`\"{} \textbackslash{}t\textbackslash{}r\textbackslash{}n\textbackslash{}a\char`\"{}
\item 
\#define \textbf{ B\+U\+F\+F\+S\+I\+ZE}~256
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ argc} (char $\ast$$\ast$n)
\begin{DoxyCompactList}\small\item\em Count the number of strings in a string array. \end{DoxyCompactList}\item 
char $\ast$ \textbf{ cmd\+\_\+prompt} (char $\ast$str\+\_\+to\+\_\+server)
\begin{DoxyCompactList}\small\item\em Prompt for the user. \end{DoxyCompactList}\item 
int \textbf{ get\+\_\+cmd} (char $\ast$$\ast$args, int n\+\_\+args)
\begin{DoxyCompactList}\small\item\em Select type of command. \end{DoxyCompactList}\item 
int \textbf{ is\+\_\+exit} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em In case of the user has selected the exit command, then exit the prompt. \end{DoxyCompactList}\item 
char $\ast$ \textbf{ read\+\_\+line} (void)
\begin{DoxyCompactList}\small\item\em read line from stdin \end{DoxyCompactList}\item 
char $\ast$$\ast$ \textbf{ split\+\_\+line} (char $\ast$)
\item 
int \textbf{ main} (int \textbf{ argc}, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\label{bash_8c_a39912bfe2a55f30e269196f9141d845d}} 
\index{bash.\+c@{bash.\+c}!B\+U\+F\+F\+S\+I\+ZE@{B\+U\+F\+F\+S\+I\+ZE}}
\index{B\+U\+F\+F\+S\+I\+ZE@{B\+U\+F\+F\+S\+I\+ZE}!bash.\+c@{bash.\+c}}
\subsubsection{B\+U\+F\+F\+S\+I\+ZE}
{\footnotesize\ttfamily \#define B\+U\+F\+F\+S\+I\+ZE~256}

\mbox{\label{bash_8c_acffba4e12894ca7015d00aaf3a2354cc}} 
\index{bash.\+c@{bash.\+c}!L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE@{L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE}}
\index{L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE@{L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE}!bash.\+c@{bash.\+c}}
\subsubsection{L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE}
{\footnotesize\ttfamily \#define L\+S\+H\+\_\+\+R\+L\+\_\+\+B\+U\+F\+S\+I\+ZE~1024}

\mbox{\label{bash_8c_a5fcc970b08ffddb25a45ab3a875f0905}} 
\index{bash.\+c@{bash.\+c}!L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE@{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE}}
\index{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE@{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE}!bash.\+c@{bash.\+c}}
\subsubsection{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE}
{\footnotesize\ttfamily \#define L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+B\+U\+F\+S\+I\+ZE~64}

\mbox{\label{bash_8c_a27250e82bec993130c5547a5671d61da}} 
\index{bash.\+c@{bash.\+c}!L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM@{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM}}
\index{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM@{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM}!bash.\+c@{bash.\+c}}
\subsubsection{L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM}
{\footnotesize\ttfamily \#define L\+S\+H\+\_\+\+T\+O\+K\+\_\+\+D\+E\+L\+IM~\char`\"{} \textbackslash{}t\textbackslash{}r\textbackslash{}n\textbackslash{}a\char`\"{}}



\subsection{Function Documentation}
\mbox{\label{bash_8c_a29367ea7e75861b6b3db15e6d3a030ce}} 
\index{bash.\+c@{bash.\+c}!argc@{argc}}
\index{argc@{argc}!bash.\+c@{bash.\+c}}
\subsubsection{argc()}
{\footnotesize\ttfamily int argc (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{n }\end{DoxyParamCaption})}



Count the number of strings in a string array. 


\begin{DoxyParams}{Parameters}
{\em n} & array of strings \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of strings 
\end{DoxyReturn}
\mbox{\label{bash_8c_a25c4fbe3c4c29c5234c424e6fbb9b84d}} 
\index{bash.\+c@{bash.\+c}!cmd\+\_\+prompt@{cmd\+\_\+prompt}}
\index{cmd\+\_\+prompt@{cmd\+\_\+prompt}!bash.\+c@{bash.\+c}}
\subsubsection{cmd\+\_\+prompt()}
{\footnotesize\ttfamily char $\ast$ cmd\+\_\+prompt (\begin{DoxyParamCaption}\item[{char $\ast$}]{str\+\_\+to\+\_\+server }\end{DoxyParamCaption})}



Prompt for the user. 

All possibilities are contemplated to achieve robust behavior of the function. This may make it look a bit complex but it is properly documented for understanding the code. 
\begin{DoxyParams}{Parameters}
{\em str\+\_\+to\+\_\+server} & String to be sent to the server \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to string  
\end{DoxyReturn}
Start of the prompt, it is kept in a do-\/while loop until the user enters a valid command.\mbox{\label{bash_8c_a4eab3617254ab77fc2a44c5ff882f5f3}} 
\index{bash.\+c@{bash.\+c}!get\+\_\+cmd@{get\+\_\+cmd}}
\index{get\+\_\+cmd@{get\+\_\+cmd}!bash.\+c@{bash.\+c}}
\subsubsection{get\+\_\+cmd()}
{\footnotesize\ttfamily int get\+\_\+cmd (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{args,  }\item[{int}]{n\+\_\+args }\end{DoxyParamCaption})}



Select type of command. 

In case the first argument is any of the valid commands, the function will return an int greater than or equal to zero. If not it will return a negative int. 
\begin{DoxyParams}{Parameters}
{\em args} & Array of tokenized strings coming from user prompt \\
\hline
{\em n\+\_\+args} & Number of elements of array args \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\label{bash_8c_a9882fc592454588fc3587f2ec03e09ab}} 
\index{bash.\+c@{bash.\+c}!is\+\_\+exit@{is\+\_\+exit}}
\index{is\+\_\+exit@{is\+\_\+exit}!bash.\+c@{bash.\+c}}
\subsubsection{is\+\_\+exit()}
{\footnotesize\ttfamily int is\+\_\+exit (\begin{DoxyParamCaption}\item[{char $\ast$}]{str }\end{DoxyParamCaption})}



In case of the user has selected the exit command, then exit the prompt. 


\begin{DoxyParams}{Parameters}
{\em str} & str\+\_\+to\+\_\+server \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\label{bash_8c_a3c04138a5bfe5d72780bb7e82a18e627}} 
\index{bash.\+c@{bash.\+c}!main@{main}}
\index{main@{main}!bash.\+c@{bash.\+c}}
\subsubsection{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$$\ast$}]{argv }\end{DoxyParamCaption})}

\mbox{\label{bash_8c_aebbd74c2b146ed63fce0a0314388ada9}} 
\index{bash.\+c@{bash.\+c}!read\+\_\+line@{read\+\_\+line}}
\index{read\+\_\+line@{read\+\_\+line}!bash.\+c@{bash.\+c}}
\subsubsection{read\+\_\+line()}
{\footnotesize\ttfamily char $\ast$ read\+\_\+line (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



read line from stdin 

\begin{DoxyReturn}{Returns}
char $\ast$ with the line 
\end{DoxyReturn}
\mbox{\label{bash_8c_a67577aefe8264c92b367fc9b4ca068a5}} 
\index{bash.\+c@{bash.\+c}!split\+\_\+line@{split\+\_\+line}}
\index{split\+\_\+line@{split\+\_\+line}!bash.\+c@{bash.\+c}}
\subsubsection{split\+\_\+line()}
{\footnotesize\ttfamily char $\ast$$\ast$ split\+\_\+line (\begin{DoxyParamCaption}\item[{char $\ast$}]{line }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em line} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
char$\ast$$\ast$ 
\end{DoxyReturn}
